# Equals와 HashCode ? 

Object class의 equals 메서드와 hashCode 메서드가 무엇인지 작성하고, 차이점과 이를 구현할 때의 주의점이 무엇인지 작성해 보자.

## 동등성과 동일성

우선 equals와 hashcode에 관해서 작성하기 전에 동등성과 동일성에 대해 짧게 정리를 하고자 한다.

쉽게 예를 들어서, 같은 핸드폰 기종, 같은 모델이어도 각각의 고유 번호가 있듯이 같지만 다르다. 이것이 동등성이다.

주민등록번호와 같이 유니크(Id)하게 가지고 있는 것, 그 값을 비교해서 완전히 동일한 것을 비교하고자 하는 것이 동일성이라 말할 수 있다.
객체 내의 메모리 주소값을 비교하고자 하는 것이다.

## equals
equals 메소드는 기본적으로 2개의 객체가 동일한지 검사하기 위해 사용된다.

```java
다른 개체가 이 개체와 "동일"한지 여부를 나타냅니다.
equals 메소드는 null이 아닌 객체 참조에 대한 등가 관계를 구현합니다.
```
2개의 객체가 참조하는 것이 동일한지를 확인하는 것이며, 이는 동일성(Identity)을 비교하는 것이다.

즉, 2개의 객체가 가리키는 곳이 동일한 메모리 주소일 경우에만 동일한 객체가 된다.

프로그래밍 중에 많은 객체들이 생성되고 동일한 객체가 메모리 상에 띄워져 있는 경우가 있다. 서로 다른 메모리에 띄워져 있으므로 동일한 객체가 아니다.
```java
    String a2 = new String("a");
    String b2 = new String("a");
    System.out.println(a2.equals(b2)); // true (동등성)
    System.out.println(a2 == b2); // false (동일성)
```
== 연산자에서는 false가 나오고 equals 메서드에서는 true의 결과를 볼 수 있는데, 이는 Object class의 메서드를 오버라이딩하여 구현했기 때문이다.(동등성 처리)

## hashCode

```java
개체의 해시 코드 값을 반환합니다.
    이 메소드는 java.util.HashMap 에서 제공하는 것과 같은 해시 테이블의 이점을 위해 지원됩니다.
```
```java
두 개체가 equals 메서드에 따라 동일한 경우 : 
    두 개체 각각에 대해 hashCode 메서드를 호출하면 동일한 정수 결과가 생성되어야 합니다.
두 개체가 equals 메서드에 따라 같지 않은 경우 :
    두 개체 각각에 대해 hashCode 메서드를 호출하여 고유한 정수 결과를 생성해야 할 필요는 없습니다. 
    그러나 프로그래머는 같지 않은 개체에 대해 고유한 정수 결과를 생성하면 
    해시 테이블의 성능이 향상될 수 있음을 알고 있어야 합니다.
```

객체의 유일한 Integer 값을 반환합니다. Object class에선 heap 영역에 저장되는 객체의 메모리 주소를 반환한다.(항상 그렇지는 않음. 예를 들면 아스키 코드를 반환한다던지..)

## equals와 hashCode 관계
앞서 이야기 했듯이 동일성을(같은 값) 확인하기 위해서는 메모리 주소값이 같아야만 한다. 동일한 객체는 hashCode가 같아야 한다.

그러기 위해선 equals 메서드와 hashCode를 override 해야하지만, **무조건 항상 같이 override를 해야하는 것은 아니다.**

하지만 동일한 값의 결과를 보기 위해 hashCode를 override하는 경우도 있을 것이다.

객체의 **동등성을 확인하기 위해 equals 메서드를 사용했다고 해서, 
항상 해당 객체들의 해시코드가 같아야 하는 것은 아니다**. 

사실, 다른 객체들이 동일한 해시코드를 가지는 경우를 해시 충돌(Collision)이라고 한다. 
해시 충돌은 해시 함수가 동일한 해시 코드를 반환하는 경우로, 
해시 함수는 일반적으로 객체의 모든 필드를 고려하지만 완벽한 해시 충돌을 피하기는 어렵다.

그리고 equals 메서드를 오버라이드했을 때 hashCode 메서드를 오버라이드하지 않아도 동작하는 경우도 있다. 
이는 Java의 Object 클래스에서 상속받은 기본 구현을 사용하는 경우이다. 
이 경우에는 객체의 동일성 비교를 위해 참조값을 기반으로 하므로 
equals 메서드가 true를 반환한다면 hashCode 메서드를 오버라이드하지 않아도 동작한다.

## 주의할 점은 ?

- hashCode의 일관성: 객체의 필드들이 변경되지 않는 한, 
equals 메서드에서 사용된 필드들만을 기반으로 hashCode 값을 계산해야 한다. 
equals 메서드에 사용되지 않는 필드들은 hashCode 값에 영향을 주지 않아야 한다. 
이는 객체가 해시 기반 자료구조에 저장된 후에도 동일한 해시코드를 유지할 수 있도록 보장한다.


- 해시 충돌 최소화: 가능한 한 해시 충돌을 최소화해야 한다. 
해시 충돌은 동일한 해시코드를 가지는 다른 객체들이 있는 경우이다. 
해시 충돌은 해시 기반 자료구조의 성능에 영향을 줄 수 있으므로, 
고려 가능한 모든 경우의 수에 대해 해시 충돌이 최소화되도록 hashCode 메서드를 구현해야 한다. 
이를 위해 해시 함수의 분포를 균등하게 유지하는 것이 중요하다.

---

내용이 틀릴 수도 있습니다. 피드백, 지적 감사히 받겠습니다 !